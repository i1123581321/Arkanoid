#  Arkanoid

本项目是一个基于街机游戏 arkanoid 的打砖块游戏，使用 SpriteKit 框架实现

![IMG_6335.PNG](https://i.loli.net/2020/12/21/vN1eqhBHa4slmfy.png)

## 游戏介绍

玩家操纵一块可移动的平板，游戏开始时会发射出小球，球可以在平板，墙以及砖块上弹跳，击中砖块砖块便会消失，同时玩家获得分数，如果击碎所有砖块就宣告玩家胜利，而如果再此之前用完了所有生命（小球没有被板接住而撞上下面的边界线就会被消灭），则游戏失败

在此基础上还扩展了多方面内容，包括

### 多种游戏模式

除了最普通的游戏模式以外，还支持无尽模式与上帝模式，在无尽模式下砖块被全部击碎后并不会游戏胜利，而是刷新新的砖块并维持原来的分数与生命数量，挑战你的极限吧！上帝模式下不会失败，每次场上没有小球后就会再次发射出三个小球，用于解压

### 丰富的强化道具

击碎砖块时会随机掉落强化道具，用板子接住道具即会获得强化效果，包括：

* 减速：减慢球的速度，小球每次碰撞都会微弱地提升速度，减速道具可以减缓球的速度
* 分裂：额外产生两个新的小球
* 激光：平板获得强化，可以定期发出激光子弹，击碎砖块
* 加长：平板的长度变长，更容易接住小球
* 额外生命：获得一条额外生命

![IMG_6338.PNG](https://i.loli.net/2020/12/21/rZtATbuhceQw8VS.png)

### 多样的砖块效果

砖块默认是组成一个矩形

![IMG_6337.PNG](https://i.loli.net/2020/12/21/8sQvROcfW51tq4L.png)

而点击主界面左下角的 random 打开随机生成选项即可生成随机字母或数字形状的砖块阵列

![IMG_6339.PNG](https://i.loli.net/2020/12/21/cCeGuJkTYgn4vR5.png)

## 模块设计

本项目按照 mvc 架构组织，在 SpriteKit 中一般惯例是只维护一个 view，多个逻辑上的场景通过不同的 scene 实现，因此 view 部分主要分为两类：三个主要场景，以及一些自定义的组件，controller 用于连接 view 与 model，同时也处理 view 之间的切换，而 model 与表现无关，主要负责游戏逻辑的判断，包括结束条件，分数等

### view

#### scene

游戏主要由三个场景组成：菜单界面，游戏界面，结束界面。菜单界面是初始时加载的界面，可以在此选择不同的游戏模式，以及选择是否随机生成砖块阵列。游戏场景是主要的场景，各个游戏元素在此进行组织，同时画面的主要逻辑也由这个场景控制（主要指物理碰撞的处理以及动画效果的表现），而结束界面则是显示玩家的游戏结果以及分数，还可以选择重新开始或是回到菜单界面

每个场景都有对应的一个 delegate 对象，在事件发生时调用对应的方法以通知需要知道信息的其他对象，对于菜单和结束界面主要是按钮按下，对于游戏界面主要是砖块消失或者小球消失等事件。

在配置场景时采用了代码与可视化编辑器结合的方式，对于静态的要素，如每个界面的背景文件，以及一些静态组件和静态组件的动作，都是通过可视化编辑器配置，而动态生成的组件则是使用代码生成，如标题和按钮都是直接在 sks 文件中配置，而砖块，小球等动态组件则是选择预先配置一个 SKNode 在 sks 文件中，然后将小球，砖块等组件作为其 child 添加到界面，这样做的好处有两点

* 减轻配置坐标的工作，子节点以父节点的锚点为原点，这样调整一系列子节点的位置只需要在 sks 文件中调整父节点的位置，而不需要修改代码
* 可以批量添加或删除一类组件

#### node

为了方便定义了一系列自定义组件，大部分都是继承自 SKSpriteNode，这样可以直接按照一般节点的方式进行添加，删除，配置动作。需要一提的是砖块随机生成的实现，是根据 16 x 8 的字模码选择在指定位置是否生成砖块，从而可以呈现出字母或是数字的形状

自定义组件初始化时也设置了物理属性，包括碰撞属性以及接触属性，在 SpriteKit 中碰撞和接触是分开处理的，便于编写游戏逻辑

除了游戏时用的组件，按钮也是自定义的组件，因为在 SpriteKit 的 scene 中不支持 UIButton，而单纯监视点击只会使得按下后处理逻辑立即触发。为了实现类似一般按钮的 touch up inside 的功能，需要重写整个场景的 touch 的一系列处理函数， 只有在开始和结束时都在按钮范围内才认为按钮被按下

### controller

controller 主要就是 view（指 storyboard 中唯一的 view）的控制器，同时也是各个场景和游戏模型的 delegate 的实现，负责处理事件发生后的行为，包括切换场景或是通知模型，而模型也会在状态更新后通知控制器，继而改变显示内容

### model

model 主要是游戏逻辑的抽象，在发生砖块消失（此时分数倍率要增加），小球击中板反弹（此时分数倍率回归初始值），小球消失（生命数减一，如果是上帝模式则是再发两个小球）等事件时需要改变对应的状态（生命数，小球数……），这些事件是 scene 通知 controller，再由 controller 通知 model 的，而当游戏开始，游戏结束等事件发生时 model 也会反过来通知 controller （通过调用 delegate 对象的方法，而 controller 在初始化 model 时会将自身设置为其 controller）
